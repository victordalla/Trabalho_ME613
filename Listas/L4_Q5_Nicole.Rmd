--- 
title: "Questão 5 da lista 4"
output: 
  pdf_document:
    fig_crop: no
header-includes:
  - \usepackage[brazil, english, portuguese]{babel}
  - \usepackage[utf8]{inputenc}
  - \usepackage[T1]{fontenc}
  - \usepackage[fixlanguage]{babelbib}
  - \usepackage{times}
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE, 
  message = FALSE,
  warning = FALSE,
  fig.align = "center", fig.height = 3, fig.width = 5
  )
options(
  OutDec = ",", 
  digits = 3, 
  knitr.table.format = "latex", 
  xtable.comment = FALSE
  )
```

```{r lib}
library(dplyr)
library(ggplot2)
library(forcats)
library(magrittr)
library(broom)
library(xtable)
library(knitr)
source("plot_functions.R")
source("comparacao_de_modelo.R")
```


## Questão 5

```{r}
# tamanhos amostrais
ns <- c(30, 50, 100)
# número de réplicas
r <- 100
# valores verdadeiros
b0 <- 1
b1 <- 1.5
#sigma2 <- 4
sigma <- 2
```


### Item a)

$Y_{i}=\beta_{0}+\beta_{1}\left(x_{i}-\overline{x}\right)+\xi_{i}$ onde $\xi_{i} \stackrel{i . i . d .}{\sim} N\left(0, \sigma^{2}\right)$.

```{r}
resultados <- tibble(
  # tibble recicla, então todas as colunas são de mesmo tamanho mas assim fica mais legível :)
  n = numeric(length(ns) * r), repl = 0,  b0.est = 0, b1.est = 0, 
  b0.lo = 0, b0.hi = 0, b1.lo = 0, b1.hi = 0, pvalor = 0
  )
i <- 0
for (n in ns) {
  x <- runif(n, 5, 20)
  xbar <- mean(x)
  
  for (repl in 1:r) {
    i <- i + 1
    y <- b0 + b1*(x-xbar) + rnorm(n, 0, sigma)
    fit <- lm(y ~ I(x-xbar))
    # fit$coefficients e confint retornam vetores, mas c() sempre tem 1 dimensão :)
    # IMPORTANTE: verificar wald.test
    resultados[i, ] <- c(
      n, repl, fit$coefficients, confint(fit, 1), confint(fit, 2), 
      wald.test(b=coef(fit), Sigma=vcov(fit), Terms=c(1,2), H0=c(1,0))$result$chi2[3]
      )
  }
}

group_by(resultados, n) %>% 
  summarise(b0.cobertura = mean(b0 >= b0.lo & b0 <= b0.hi), b1.cobertura = mean(b1 >= b1.lo & b1 <= b1.hi))
```

```{r}
# ggarange não é a melhor solução :(
p <- ggplot(resultados, aes(repl)) + facet_wrap(~n) + theme_classic()
ggpubr::ggarrange(
  nrow = 2, labels = c("b0", "b1"), 
  p + geom_ribbon(aes(ymin=b0.lo, ymax=b0.hi), fill = "coral", alpha = 0.3) + 
  geom_hline(yintercept = b0, col = "cadetblue"), 
  p + geom_ribbon(aes(ymin=b1.lo, ymax=b1.hi), fill = "coral", alpha = 0.3) + 
  geom_hline(yintercept = b1, col = "cadetblue")
)
```

```{r}
ggpubr::ggarrange(
  nrow = 2, labels = c("b0", "b1"), 
  ggplot(resultados, aes(b0)) + geom_histogram() + facet_wrap(~n) + theme_classic(), 
  ggplot(resultados, aes(b1)) + geom_histogram() + facet_wrap(~n) + theme_classic()
)
```



```{r}
set.seed(204186)
n <- 50 # tamanho da amostra 
# numero de replicas da simulação
# ->conjunto de valores de Y para um mesmo conjunto de x
r <- 100
b0 <- 1
b1 <- 1.5
sigma2 <- 4

x <- runif(n, 5, 20)
y <- matrix(data= NA, nrow = n, ncol = r) #cada coluna é uma amostra

b1_hat <- matrix(data= NA, nrow = r, ncol = 4)
b0_hat <- matrix(data= NA, nrow = r, ncol = 4)
sigma2_hat <- c()

##sum(y[,i]*(x- mean(x)))/ sum((x - mean(x))^2)

for (i in 1:r) {

  y[,i] <- b0 + b1*(x - mean(x)) + rnorm(n, mean = 0, sd= sqrt(sigma2))
  model <- lm(y[,i] ~ I(x - mean(x)))
  stats <- tidy(model, conf.int = TRUE)
  
  b1_hat[i, 1] <- stats$estimate[2]
  b1_hat[i, 2] <- stats$p.value[2] #testa de b1 = 0
  b1_hat[i, 3] <- stats$conf.low[2]
  b1_hat[i, 4] <- stats$conf.high[2]
  
  b0_hat[i, 1] <- stats$estimate[1]
  b0_hat[i, 2] <- stats$p.value[1]
  b0_hat[i, 3] <- stats$conf.low[1]
  b0_hat[i, 4] <- stats$conf.high[1]
  
  sigma2_hat[i] <- sum((y[,i] - b0_hat[,1] - b1_hat[,1]*(x - mean(x)))^2)/n-2
}

b0_hat <- as.data.frame(b0_hat)
colnames(b0_hat) <- c("estimativa", "p-valor", "ic.low", "ic.high")

teste <- data.frame(Variable = rownames(summary(model)$coef),
                    coefficient = summary(model)$coef[,1],
                    SE= summary(model)$coef[,2])
interval <- qnorm((1-0.95)/2)

ggplot(b0_hat, aes(x = 1:r, y = estimativa)) +
  geom_point(size = 1) +
  geom_errorbar(aes(ymax = ic.high, ymin = ic.low))+
  hline

hist(sigma2_hat)

```




